package com.fantamomo.mc.amongus.languages

import com.fantamomo.mc.amongus.AmongUs
import net.kyori.adventure.text.minimessage.MiniMessage
import net.kyori.adventure.translation.GlobalTranslator
import org.slf4j.LoggerFactory
import java.io.InputStreamReader
import java.io.Reader
import java.nio.file.FileVisitResult
import java.nio.file.Files
import java.nio.file.Path
import java.util.*
import kotlin.io.path.*

object LanguageManager {

    private val logger = LoggerFactory.getLogger("AmongUsLanguageManager")

    private val externDirectory = AmongUs.dataPath.resolve("languages")
    private const val INNER_DIRECTORY = "lang"
    private const val LANGUAGES_LIST_FILE = "$INNER_DIRECTORY/languages.txt"

    private var languagesList: List<Locale> = emptyList()
    private val loadedLanguages: MutableMap<Locale, Language> = mutableMapOf()

    const val VERSION_KEY = "version"

    fun init() {
        logger.info("Initializing LanguageManager{}", if (AmongUs.IN_DEVELOPMENT) " (DEV mode)" else "")

        Files.createDirectories(externDirectory)

        loadLanguageList()
        syncLanguagesFromInternal()
        loadExternLanguages()
        addLanguagesToGlobalTranslator()

        logger.info(
            "LanguageManager initialized. Loaded {} languages",
            loadedLanguages.size
        )
    }

    private fun addLanguagesToGlobalTranslator() {
        loadedLanguages.forEach { (locale, language) ->
            GlobalTranslator.translator().addSource(language)
            logger.debug("Registered language {} to GlobalTranslator", locale)
        }
    }

    private fun loadLanguageList() {
        logger.debug("Loading language list from {}", LANGUAGES_LIST_FILE)

        val stream = javaClass.classLoader.getResourceAsStream(LANGUAGES_LIST_FILE)
        if (stream == null) {
            logger.error("Unable to load languages list (resource missing)")
            return
        }

        languagesList = stream.bufferedReader().readLines().mapNotNull {
            val locale = getLocaleFromString(it)
            if (locale == null) {
                logger.error("Invalid locale '{}' in {}", it, LANGUAGES_LIST_FILE)
            }
            locale
        }

        if (languagesList.isEmpty()) {
            logger.error("No valid locales found in {}", LANGUAGES_LIST_FILE)
        } else if (Locale.US !in languagesList) {
            logger.warn("en_US is missing in {}, it is the default language", LANGUAGES_LIST_FILE)
        }

        logger.info("Found {} supported locales", languagesList.size)
    }

    private fun syncLanguagesFromInternal() {
        logger.info("Synchronizing language files from internal resources")

        for (locale in languagesList) {
            val fileName = "lang_${locale}.properties"
            val internalPath = "$INNER_DIRECTORY/$fileName"
            val externalFile = externDirectory.resolve(fileName)

            val internalStream = javaClass.classLoader.getResourceAsStream(internalPath)
            if (internalStream == null) {
                logger.error("Internal language file missing: {}", internalPath)
                continue
            }

            val internalProps = Properties().apply {
                load(InputStreamReader(internalStream))
            }

            if (AmongUs.IN_DEVELOPMENT) {
                externalFile.outputStream().use {
                    internalProps.store(it, null)
                }
                logger.debug("Overwrote language file {} (DEV mode)", fileName)
                continue
            }

            // ---- PROD MODE ----

            val internalVersion = internalProps.getVersion()

            if (!externalFile.exists()) {
                externalFile.outputStream().use {
                    internalProps.store(it, "Generated by AmongUs")
                }
                logger.info("Created new language file {}", fileName)
                continue
            }

            val externalProps = Properties().apply {
                externalFile.inputStream().use { load(it) }
            }

            val externalVersion = externalProps.getVersion()

            when {
                internalVersion > externalVersion -> {
                    externalFile.outputStream().use {
                        internalProps.store(it, "Updated by AmongUs")
                    }
                    logger.info(
                        "Updated language {} ({} â†’ {})",
                        locale, externalVersion, internalVersion
                    )
                }

                internalVersion < externalVersion -> {
                    logger.debug(
                        "External language {} is newer ({} > {}), skipping",
                        locale, externalVersion, internalVersion
                    )
                }

                else -> {
                    logger.debug(
                        "Language {} is up to date (version {})",
                        locale, internalVersion
                    )
                }
            }
        }
    }

    private fun loadExternLanguages() {
        logger.info("Loading external language files from {}", externDirectory)

        externDirectory.visitFileTree {
            onVisitFile { file, _ ->
                if (file.extension == "properties") {
                    try {
                        loadExternLanguage(file)
                    } catch (e: Exception) {
                        logger.error("Failed to load external language {}", file.fileName, e)
                    }
                }
                FileVisitResult.CONTINUE
            }
        }
    }

    private fun loadExternLanguage(file: Path) {
        val localeName = file.nameWithoutExtension.removePrefix("lang_")
        val locale = getLocaleFromString(localeName)
            ?: throw IllegalArgumentException("Invalid locale name: $localeName")

        file.bufferedReader().use {
            loadLanguage(locale, it)
        }

        logger.info("Loaded language {} from {}", locale, file.fileName)
    }

    private fun loadLanguage(locale: Locale, reader: Reader) {
        val properties = Properties()
        properties.load(reader)

        loadedLanguages[locale] =
            Language(locale, properties, MiniMessage.miniMessage())
    }

    private fun Properties.getVersion() =
        getProperty(VERSION_KEY)?.toIntOrNull() ?: 0

    @Suppress("DEPRECATION")
    private fun getLocaleFromString(locale: String): Locale? {
        val parts = locale.split("_")
        return when (parts.size) {
            1 -> Locale(parts[0])
            2 -> Locale(parts[0], parts[1])
            3 -> Locale(parts[0], parts[1], parts[2])
            else -> null
        }
    }
}