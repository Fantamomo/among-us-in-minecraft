package com.fantamomo.mc.amongus.languages

import com.fantamomo.mc.amongus.AmongUs
import net.kyori.adventure.text.minimessage.MiniMessage
import net.kyori.adventure.translation.GlobalTranslator
import org.slf4j.LoggerFactory
import java.io.InputStreamReader
import java.io.Reader
import java.nio.file.FileVisitResult
import java.nio.file.Files
import java.nio.file.Path
import java.util.*
import kotlin.io.path.*

object LanguageManager {

    private val logger = LoggerFactory.getLogger("AmongUsLanguageManager")

    private val externDirectory: Path = AmongUs.dataPath.resolve("languages")
    private const val INNER_DIRECTORY = "lang"
    private const val LANGUAGES_LIST_FILE = "$INNER_DIRECTORY/languages.txt"
    val ROOT_LOCALE: Locale = Locale.US

    private var languagesList: List<Locale> = emptyList()
    private val loadedLanguages: MutableMap<Locale, Language> = mutableMapOf()
    private var englishLanguage: Language? = null

    const val VERSION_KEY = "version"

    fun init() {
        logger.info("Initializing LanguageManager")

        Files.createDirectories(externDirectory)

        loadLanguageList()
        syncLanguagesFromInternal()
        loadExternalLanguages()
        registerLanguagesToGlobalTranslator()

        logger.info("LanguageManager initialized. Loaded {} languages", loadedLanguages.size)
    }

    private fun registerLanguagesToGlobalTranslator() {
        val englishLanguage = englishLanguage
        loadedLanguages.forEach { (locale, language) ->
            if (language == englishLanguage) return@forEach
            GlobalTranslator.translator().addSource(language)
            logger.debug("Registered language {} to GlobalTranslator", locale)
        }

        if (englishLanguage == null) return
        GlobalTranslator.translator().addSource(englishLanguage)
        logger.debug("Registered english language to GlobalTranslator")
    }

    private fun loadLanguageList() {
        logger.debug("Loading language list from {}", LANGUAGES_LIST_FILE)

        val stream = javaClass.classLoader.getResourceAsStream(LANGUAGES_LIST_FILE)
        if (stream == null) {
            logger.error("Unable to load languages list (resource missing)")
            return
        }

        languagesList = stream.bufferedReader().useLines { lines ->
            lines.mapNotNull { line ->
                val locale = parseLocale(line)
                if (locale == null) logger.error("Invalid locale '{}' in {}", line, LANGUAGES_LIST_FILE)
                locale
            }.toList()
        }

        when {
            languagesList.isEmpty() -> logger.error("No valid locales found in {}", LANGUAGES_LIST_FILE)
            ROOT_LOCALE !in languagesList -> logger.warn("{} is missing in {}, it is the default language", ROOT_LOCALE.toLanguageTag(), LANGUAGES_LIST_FILE)
        }

        logger.info("Found {} supported locales", languagesList.size)
    }

    private fun syncLanguagesFromInternal() {
        logger.info("Synchronizing language files from internal resources")

        languagesList.forEach { locale ->
            val fileName = "lang_${locale}.properties"
            val internalPath = "$INNER_DIRECTORY/$fileName"
            val externalFile = externDirectory.resolve(fileName)

            val internalStream = javaClass.classLoader.getResourceAsStream(internalPath)
            if (internalStream == null) {
                logger.error("Internal language file missing: {}", internalPath)
                return@forEach
            }

            val internalProps = Properties().apply { load(InputStreamReader(internalStream)) }
            val internalVersion = internalProps.getVersion()

            if (AmongUs.IN_DEVELOPMENT) {
                externalFile.outputStream().use { internalProps.store(it, null) }
                logger.debug("Overwrote language file {} (DEV mode)", fileName)
                return@forEach
            }

            if (!externalFile.exists()) {
                externalFile.outputStream().use { internalProps.store(it, "Generated by AmongUs in Minecraft") }
                logger.info("Created new language file {}", fileName)
                return@forEach
            }

            val externalProps = Properties().apply { externalFile.inputStream().use { load(it) } }
            val externalVersion = externalProps.getVersion()

            when {
                internalVersion > externalVersion -> {
                    externalFile.outputStream().use { internalProps.store(it, "Updated by AmongUs in Minecraft") }
                    logger.info("Updated language {} ({} â†’ {})", locale, externalVersion, internalVersion)
                }
                internalVersion < externalVersion -> logger.debug("External language {} is newer ({} > {}), skipping", locale, externalVersion, internalVersion)
                else -> logger.debug("Language {} is up to date (version {})", locale, internalVersion)
            }
        }
    }

    private fun loadExternalLanguages() {
        logger.info("Loading external language files from {}", externDirectory)

        if (!externDirectory.exists()) return

        externDirectory.visitFileTree {
            onVisitFile { file, _ ->
                if (file.extension.equals("properties", ignoreCase = true)) {
                    try {
                        loadExternalLanguage(file)
                    } catch (e: Exception) {
                        logger.error("Failed to load external language {}", file.fileName, e)
                    }
                }
                FileVisitResult.CONTINUE
            }
        }
    }

    private fun loadExternalLanguage(file: Path) {
        val localeName = file.nameWithoutExtension.removePrefix("lang_")
        val locale = parseLocale(localeName) ?: throw IllegalArgumentException("Invalid locale name: $localeName")

        file.bufferedReader().use { reader ->
            loadLanguage(locale, reader)
        }

        logger.info("Loaded language {} from {}", locale, file.fileName)
    }

    private fun loadLanguage(locale: Locale, reader: Reader) {
        val properties = Properties().apply { load(reader) }
        val language = Language(locale, properties, MiniMessage.miniMessage())
        if (locale == ROOT_LOCALE) englishLanguage = language
        loadedLanguages[locale] = language
    }

    private fun Properties.getVersion() =
        getProperty(VERSION_KEY)?.toIntOrNull() ?: 0

    @Suppress("DEPRECATION")
    private fun parseLocale(localeString: String): Locale? {
        val parts = localeString.split("_")
        return when (parts.size) {
            1 -> Locale(parts[0])
            2 -> Locale(parts[0], parts[1])
            3 -> Locale(parts[0], parts[1], parts[2])
            else -> null
        }
    }
}